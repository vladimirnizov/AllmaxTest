{
  "version": 3,
  "file": "ngxs-store.umd.min.js",
  "sources": [
    "ng://@ngxs/store/packages/store/src/symbols.ts",
    "ng://@ngxs/store/packages/store/src/internal/internals.ts",
    "ng://@ngxs/store/packages/store/src/utils/utils.ts",
    "ng://@ngxs/store/packages/store/src/operators/of-action.ts",
    "ng://@ngxs/store/packages/store/src/operators/zone.ts",
    "ng://@ngxs/store/packages/store/src/actions-stream.ts",
    "ng://@ngxs/store/packages/store/src/utils/compose.ts",
    "ng://@ngxs/store/packages/store/src/internal/state-stream.ts",
    "ng://@ngxs/store/packages/store/src/plugin-manager.ts",
    "ng://@ngxs/store/packages/store/src/internal/dispatcher.ts",
    "ng://@ngxs/store/packages/store/src/utils/freeze.ts",
    "ng://@ngxs/store/packages/store/src/internal/state-operations.ts",
    "ng://@ngxs/store/packages/store/src/internal/state-context-factory.ts",
    "ng://@ngxs/store/packages/store/src/internal/state-factory.ts",
    "ng://@ngxs/store/packages/store/src/utils/memoize.ts",
    "ng://@ngxs/store/packages/store/src/utils/selector-utils.ts",
    "ng://@ngxs/store/packages/store/src/store.ts",
    "ng://@ngxs/store/packages/store/src/decorators/select.ts",
    "ng://@ngxs/store/packages/store/src/actions/actions.ts",
    "ng://@ngxs/store/packages/store/src/module.ts",
    "ng://@ngxs/store/packages/store/src/decorators/state.ts",
    "ng://@ngxs/store/packages/store/src/decorators/action.ts",
    "ng://@ngxs/store/packages/store/src/decorators/selector.ts"
  ],
  "sourcesContent": [
    "import { InjectionToken } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nexport const ROOT_STATE_TOKEN = new InjectionToken<any>('ROOT_STATE_TOKEN');\nexport const FEATURE_STATE_TOKEN = new InjectionToken<any>('FEATURE_STATE_TOKEN');\nexport const META_KEY = 'NGXS_META';\nexport const SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n\nexport const NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nexport type NgxsPluginConstructor = new (...args: any[]) => NgxsPlugin;\nexport type NgxsPluginFn = (state: any, mutation: any, next: NgxsNextPluginFn) => any;\n\n/**\n * The NGXS config settings.\n */\nexport class NgxsConfig {\n  /**\n   * Run in development mode. This will add additional debugging features:\n   * - Object.freeze on the state and actions to guarantee immutability\n   * (default: false)\n   */\n  developmentMode: boolean;\n}\n\n/**\n * State context provided to the actions in the state.\n */\nexport interface StateContext<T> {\n  /**\n   * Get the current state.\n   */\n  getState(): T;\n\n  /**\n   * Reset the state to a new value.\n   */\n  setState(val: T);\n\n  /**\n   * Patch the existing state with the provided value.\n   */\n  patchState(val: Partial<T>);\n\n  /**\n   * Dispatch a new action and return the dispatched observable.\n   */\n  dispatch(actions: any | any[]): Observable<void>;\n}\n\nexport type NgxsNextPluginFn = (state: any, mutation: any) => any;\n\n/**\n * Plugin interface\n */\nexport interface NgxsPlugin {\n  /**\n   * Handle the state/action before its submitted to the state handlers.\n   */\n  handle(state: any, action: any, next: NgxsNextPluginFn): any;\n}\n\n/**\n * Options that can be provided to the store.\n */\nexport interface StoreOptions<T> {\n  /**\n   * Name of the state. Required.\n   */\n  name: string;\n\n  /**\n   * Default values for the state. If not provided, uses empty object.\n   */\n  defaults?: T;\n\n  /**\n   * Sub states for the given state.\n   */\n  children?: any[];\n}\n\n/**\n * Actions that can be provided in a action decorator.\n */\nexport interface ActionOptions {\n  /**\n   * Cancel the previous uncompleted observable(s).\n   */\n  cancelUncompleted?: boolean;\n}\n\n/**\n * On init interface\n */\nexport interface NgxsOnInit {\n  ngxsOnInit(ctx?: StateContext<any>): void | any;\n}\n\nexport type NgxsLifeCycle = Partial<NgxsOnInit>;\n",
    "import { META_KEY, ActionOptions, SELECTOR_META_KEY } from '../symbols';\nimport { Observable } from 'rxjs';\n\nexport interface ObjectKeyMap<T> {\n  [key: string]: T;\n}\n\nexport interface StateClass {\n  [META_KEY]?: MetaDataModel;\n}\n\nexport type StateKeyGraph = ObjectKeyMap<string[]>;\n\nexport interface ActionHandlerMetaData {\n  fn: string;\n  options: ActionOptions;\n  type: string;\n}\n\nexport interface StateOperations<T> {\n  getState(): T;\n  setState(val: T);\n  dispatch(actions: any | any[]): Observable<void>;\n}\n\nexport interface MetaDataModel {\n  name: string;\n  actions: ObjectKeyMap<ActionHandlerMetaData[]>;\n  defaults: any;\n  path: string;\n  children: StateClass[];\n  instance: any;\n}\n\nexport type SelectFromState = (state: any) => any;\n\nexport interface SelectorMetaDataModel {\n  selectFromAppState: SelectFromState;\n  originalFn: Function;\n  containerClass: any;\n  selectorName: string;\n}\n\nexport interface MappedStore {\n  name: string;\n  actions: ObjectKeyMap<ActionHandlerMetaData[]>;\n  defaults: any;\n  instance: any;\n  depth: string;\n}\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nexport function ensureStoreMetadata(target): MetaDataModel {\n  if (!target.hasOwnProperty(META_KEY)) {\n    const defaultMetadata: MetaDataModel = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n      children: [],\n      instance: null\n    };\n\n    Object.defineProperty(target, META_KEY, { value: defaultMetadata });\n  }\n  return getStoreMetadata(target);\n}\n\n/**\n * Get the metadata attached to the class if it exists.\n *\n * @ignore\n */\nexport function getStoreMetadata(target): MetaDataModel {\n  return target[META_KEY];\n}\n\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nexport function ensureSelectorMetadata(target): SelectorMetaDataModel {\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n    const defaultMetadata: SelectorMetaDataModel = {\n      selectFromAppState: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null\n    };\n\n    Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });\n  }\n\n  return getSelectorMetadata(target);\n}\n\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nexport function getSelectorMetadata(target): SelectorMetaDataModel {\n  return target[SELECTOR_META_KEY];\n}\n\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nexport function fastPropGetter(paths: string[]): (x: any) => any {\n  const segments = paths;\n  let seg = 'store.' + segments[0];\n  let i = 0;\n  const l = segments.length;\n\n  let expr = seg;\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n\n  const fn = new Function('store', 'return ' + expr + ';');\n\n  return <(x: any) => any>fn;\n}\n\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nexport function buildGraph(stateClasses: StateClass[]): StateKeyGraph {\n  const findName = (stateClass: StateClass) => {\n    const meta = stateClasses.find(g => g === stateClass);\n    if (!meta) {\n      throw new Error(`Child state not found: ${stateClass}`);\n    }\n\n    if (!meta[META_KEY]) {\n      throw new Error('States must be decorated with @State() decorator');\n    }\n\n    return meta[META_KEY].name;\n  };\n\n  return stateClasses.reduce<StateKeyGraph>((result: StateKeyGraph, stateClass: StateClass) => {\n    if (!stateClass[META_KEY]) {\n      throw new Error('States must be decorated with @State() decorator');\n    }\n\n    const { name, children } = stateClass[META_KEY];\n    result[name] = (children || []).map(findName);\n    return result;\n  }, {});\n}\n\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nexport function nameToState(states: StateClass[]): ObjectKeyMap<StateClass> {\n  return states.reduce<ObjectKeyMap<StateClass>>((result: ObjectKeyMap<StateClass>, stateClass: StateClass) => {\n    if (!stateClass[META_KEY]) {\n      throw new Error('States must be decorated with @State() decorator');\n    }\n\n    const meta = stateClass[META_KEY];\n    result[meta.name] = stateClass;\n    return result;\n  }, {});\n}\n\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nexport function findFullParentPath(obj: StateKeyGraph, newObj: ObjectKeyMap<string> = {}): ObjectKeyMap<string> {\n  const visit = (child: StateKeyGraph, keyToFind: string): string => {\n    for (const key in child) {\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n        const parent = visit(child, key);\n        return parent !== null ? `${parent}.${key}` : key;\n      }\n    }\n    return null;\n  };\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const parent = visit(obj, key);\n      newObj[key] = parent ? `${parent}.${key}` : key;\n    }\n  }\n\n  return newObj;\n}\n\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nexport function topologicalSort(graph: StateKeyGraph): string[] {\n  const sorted: string[] = [];\n  const visited: ObjectKeyMap<boolean> = {};\n\n  const visit = (name: string, ancestors: string[] = []) => {\n    if (!Array.isArray(ancestors)) {\n      ancestors = [];\n    }\n\n    ancestors.push(name);\n    visited[name] = true;\n\n    graph[name].forEach((dep: string) => {\n      if (ancestors.indexOf(dep) >= 0) {\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n      }\n\n      if (visited[dep]) {\n        return;\n      }\n\n      visit(dep, ancestors.slice(0));\n    });\n\n    if (sorted.indexOf(name) < 0) {\n      sorted.push(name);\n    }\n  };\n\n  Object.keys(graph).forEach(k => visit(k));\n\n  return sorted.reverse();\n}\n\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\nexport function isObject(obj) {\n  return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';\n}\n",
    "/**\n * Returns the type from an action instance.\n * @ignore\n */\nexport function getActionTypeFromInstance(action: any): string {\n  if (action.constructor && action.constructor.type) {\n    return action.constructor.type;\n  }\n\n  return action.type;\n}\n\n/**\n * Matches a action\n * @ignore\n */\nexport function actionMatcher(action1: any) {\n  const type1 = getActionTypeFromInstance(action1);\n\n  return function(action2: any) {\n    return type1 === getActionTypeFromInstance(action2);\n  };\n}\n\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nexport const setValue = (obj: any, prop: string, val: any) => {\n  obj = { ...obj };\n\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = { ...acc[part] };\n    }\n\n    return acc && acc[part];\n  }, obj);\n\n  return obj;\n};\n\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nexport const getValue = (obj: any, prop: string) =>\n  prop.split('.').reduce((acc: any, part: string) => acc && acc[part], obj);\n",
    "import { OperatorFunction, Observable } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\nimport { getActionTypeFromInstance } from '../utils/utils';\nimport { ActionContext, ActionStatus } from '../actions-stream';\n\nexport function ofAction<T>(allowedType): OperatorFunction<any, T>;\nexport function ofAction<T>(...allowedTypes): OperatorFunction<any, T>;\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nexport function ofAction(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes);\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nexport function ofActionDispatched(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes, ActionStatus.Dispatched);\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nexport function ofActionSuccessful(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes, ActionStatus.Successful);\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nexport function ofActionCanceled(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes, ActionStatus.Canceled);\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nexport function ofActionErrored(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes, ActionStatus.Errored);\n}\n\nfunction ofActionOperator(allowedTypes: any[], status?: ActionStatus) {\n  const allowedMap = createAllowedMap(allowedTypes);\n  return function(o: Observable<any>) {\n    return o.pipe(filterStatus(allowedMap, status), mapAction());\n  };\n}\n\nfunction filterStatus(allowedTypes: { [key: string]: boolean }, status?: ActionStatus) {\n  return filter((ctx: ActionContext) => {\n    const actionType = getActionTypeFromInstance(ctx.action);\n    const type = allowedTypes[actionType];\n    return status ? type && ctx.status === status : type;\n  });\n}\n\nfunction mapAction() {\n  return map((ctx: ActionContext) => ctx.action);\n}\n\nfunction createAllowedMap(types: any[]): { [key: string]: boolean } {\n  return types.reduce((acc: any, klass: any) => {\n    acc[getActionTypeFromInstance(klass)] = true;\n    return acc;\n  }, {});\n}\n",
    "import { Observable, Observer } from 'rxjs';\nimport { NgZone } from '@angular/core';\n\n/**\n * Operator to run the `subscribe` in a Angular zone.\n */\nexport function enterZone<T>(zone: NgZone) {\n  return (source: Observable<T>) => {\n    return new Observable((sink: Observer<T>) => {\n      return source.subscribe({\n        next(x) {\n          zone.run(() => sink.next(x));\n        },\n        error(e) {\n          zone.run(() => sink.error(e));\n        },\n        complete() {\n          zone.run(() => sink.complete());\n        }\n      });\n    });\n  };\n}\n",
    "import { Injectable, NgZone } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\n\nimport { enterZone } from './operators/zone';\n\n/**\n * Status of a dispatched action\n */\nexport const enum ActionStatus {\n  Dispatched = 'DISPATCHED',\n  Successful = 'SUCCESSFUL',\n  Canceled = 'CANCELED',\n  Errored = 'ERRORED'\n}\n\nexport interface ActionContext {\n  status: ActionStatus;\n  action: any;\n  error?: Error;\n}\n\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nexport class OrderedSubject<T> extends Subject<T> {\n  private _itemQueue: T[] = [];\n  private _busyPushingNext = false;\n\n  next(value?: T): void {\n    if (this._busyPushingNext) {\n      this._itemQueue.unshift(value);\n      return;\n    }\n    this._busyPushingNext = true;\n    super.next(value);\n    while (this._itemQueue.length > 0) {\n      const nextValue = this._itemQueue.pop();\n      super.next(nextValue);\n    }\n    this._busyPushingNext = false;\n  }\n}\n\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\n@Injectable()\nexport class InternalActions extends OrderedSubject<ActionContext> {}\n\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\n@Injectable()\nexport class Actions extends Observable<any> {\n  constructor(actions$: InternalActions, ngZone: NgZone) {\n    super(observer => {\n      actions$\n        .pipe(enterZone(ngZone))\n        .subscribe(res => observer.next(res), err => observer.error(err), () => observer.complete());\n    });\n  }\n}\n",
    "/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nexport const compose = funcs => (...args) => {\n  const curr = funcs.shift();\n  return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n",
    "import { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\n@Injectable()\nexport class StateStream extends BehaviorSubject<any> {\n  constructor() {\n    super({});\n  }\n}\n",
    "import { Injectable, Optional, SkipSelf, Inject } from '@angular/core';\nimport { NgxsPluginFn, NGXS_PLUGINS, NgxsPlugin } from './symbols';\n\n/**\n * Plugin manager class\n * @ignore\n */\n@Injectable()\nexport class PluginManager {\n  plugins: NgxsPluginFn[] = [];\n\n  constructor(\n    @Optional()\n    @SkipSelf()\n    private _parentManager: PluginManager,\n    @Inject(NGXS_PLUGINS)\n    @Optional()\n    private _plugins: NgxsPlugin[]\n  ) {\n    this.register();\n  }\n\n  private register() {\n    if (!this._plugins) {\n      return;\n    }\n\n    this.plugins = this._plugins.map(plugin => {\n      if (plugin.handle) {\n        return plugin.handle.bind(plugin);\n      } else {\n        return plugin;\n      }\n    });\n\n    if (this._parentManager) {\n      this._parentManager.plugins.push(...this.plugins);\n    }\n  }\n}\n",
    "import { Injectable, ErrorHandler, NgZone } from '@angular/core';\nimport { Observable, of, forkJoin, empty, Subject, throwError } from 'rxjs';\nimport { shareReplay, filter, exhaustMap, take } from 'rxjs/operators';\n\nimport { compose } from '../utils/compose';\nimport { InternalActions, ActionStatus, ActionContext } from '../actions-stream';\nimport { StateStream } from './state-stream';\nimport { PluginManager } from '../plugin-manager';\nimport { enterZone } from '../operators/zone';\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\n@Injectable()\nexport class InternalDispatchedActionResults extends Subject<ActionContext> {}\n\n@Injectable()\nexport class InternalDispatcher {\n  constructor(\n    private _errorHandler: ErrorHandler,\n    private _actions: InternalActions,\n    private _actionResults: InternalDispatchedActionResults,\n    private _pluginManager: PluginManager,\n    private _stateStream: StateStream,\n    private _ngZone: NgZone\n  ) {}\n\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(event: any | any[]): Observable<any> {\n    const result: Observable<any> = this._ngZone.runOutsideAngular(() => {\n      if (Array.isArray(event)) {\n        return forkJoin(event.map(a => this.dispatchSingle(a)));\n      } else {\n        return this.dispatchSingle(event);\n      }\n    });\n\n    result.subscribe({\n      error: error => this._ngZone.run(() => this._errorHandler.handleError(error))\n    });\n\n    return result.pipe(enterZone(this._ngZone));\n  }\n\n  private dispatchSingle(action: any): Observable<any> {\n    const prevState = this._stateStream.getValue();\n    const plugins = this._pluginManager.plugins;\n\n    return (compose([\n      ...plugins,\n      (nextState, nextAction) => {\n        if (nextState !== prevState) {\n          this._stateStream.next(nextState);\n        }\n        const actionResult$ = this.getActionResultStream(nextAction);\n        actionResult$.subscribe(ctx => this._actions.next(ctx));\n        this._actions.next({ action: nextAction, status: ActionStatus.Dispatched });\n        return this.createDispatchObservable(actionResult$);\n      }\n    ])(prevState, action) as Observable<any>).pipe(shareReplay());\n  }\n\n  private getActionResultStream(action: any): Observable<ActionContext> {\n    return this._actionResults.pipe(\n      filter((ctx: ActionContext) => ctx.action === action && ctx.status !== ActionStatus.Dispatched),\n      take(1),\n      shareReplay()\n    );\n  }\n\n  private createDispatchObservable(actionResult$: Observable<ActionContext>): Observable<any> {\n    return actionResult$\n      .pipe(\n        exhaustMap((ctx: ActionContext) => {\n          switch (ctx.status) {\n            case ActionStatus.Successful:\n              return of(this._stateStream.getValue());\n            case ActionStatus.Errored:\n              return throwError(ctx.error);\n            default:\n              return empty();\n          }\n        })\n      )\n      .pipe(shareReplay());\n  }\n}\n",
    "/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nexport const deepFreeze = o => {\n  Object.freeze(o);\n\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      hasOwnProp.call(o, prop) &&\n      (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n};\n",
    "import { Injectable } from '@angular/core';\n\nimport { StateOperations } from '../internal/internals';\nimport { InternalDispatcher } from '../internal/dispatcher';\nimport { StateStream } from './state-stream';\nimport { NgxsConfig } from '../symbols';\nimport { deepFreeze } from '../utils/freeze';\n\n/**\n * State Context factory class\n * @ignore\n */\n@Injectable()\nexport class InternalStateOperations {\n  constructor(\n    private _stateStream: StateStream,\n    private _dispatcher: InternalDispatcher,\n    private _config: NgxsConfig\n  ) {}\n\n  /**\n   * Returns the root state operators.\n   */\n  getRootStateOperations(): StateOperations<any> {\n    const rootStateOperations = {\n      getState: () => this._stateStream.getValue(),\n      setState: newState => this._stateStream.next(newState),\n      dispatch: actions => this._dispatcher.dispatch(actions)\n    };\n\n    if (this._config.developmentMode) {\n      return this.ensureStateAndActionsAreImmutable(rootStateOperations);\n    }\n\n    return rootStateOperations;\n  }\n\n  private ensureStateAndActionsAreImmutable(root: StateOperations<any>): StateOperations<any> {\n    return {\n      getState: () => root.getState(),\n      setState: value => {\n        const frozenValue = deepFreeze(value);\n        return root.setState(frozenValue);\n      },\n      dispatch: actions => {\n        return root.dispatch(actions);\n      }\n    };\n  }\n}\n",
    "import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nimport { StateContext } from '../symbols';\nimport { MappedStore } from '../internal/internals';\nimport { setValue, getValue } from '../utils/utils';\nimport { InternalStateOperations } from '../internal/state-operations';\n\n/**\n * State Context factory class\n * @ignore\n */\n@Injectable()\nexport class StateContextFactory {\n  constructor(private _internalStateOperations: InternalStateOperations) {}\n\n  /**\n   * Create the state context\n   */\n  createStateContext(metadata: MappedStore): StateContext<any> {\n    const root = this._internalStateOperations.getRootStateOperations();\n    return {\n      getState(): any {\n        const state = root.getState();\n        return getValue(state, metadata.depth);\n      },\n      patchState(val: any): any {\n        const isArray = Array.isArray(val);\n        const isPrimitive = typeof val !== 'object';\n\n        if (isArray) {\n          throw new Error('Patching arrays is not supported.');\n        } else if (isPrimitive) {\n          throw new Error('Patching primitives is not supported.');\n        }\n\n        const state = root.getState();\n        const local = getValue(state, metadata.depth);\n        const clone = { ...local };\n\n        for (const k in val) {\n          clone[k] = val[k];\n        }\n\n        const newState = setValue(state, metadata.depth, clone);\n        root.setState(newState);\n        return newState;\n      },\n      setState(val: any): any {\n        let state = root.getState();\n        state = setValue(state, metadata.depth, val);\n        root.setState(state);\n        return state;\n      },\n      dispatch(actions: any | any[]): Observable<any> {\n        return root.dispatch(actions);\n      }\n    };\n  }\n}\n",
    "import { Injector, Injectable, SkipSelf, Optional } from '@angular/core';\nimport { Observable, of, forkJoin, from, throwError } from 'rxjs';\nimport { shareReplay, takeUntil, map, catchError, filter, mergeMap, defaultIfEmpty } from 'rxjs/operators';\n\nimport { META_KEY, NgxsLifeCycle } from '../symbols';\nimport {\n  topologicalSort,\n  buildGraph,\n  findFullParentPath,\n  nameToState,\n  isObject,\n  StateClass,\n  MappedStore\n} from './internals';\nimport { getActionTypeFromInstance, setValue } from '../utils/utils';\nimport { ofActionDispatched } from '../operators/of-action';\nimport { InternalActions, ActionStatus, ActionContext } from '../actions-stream';\nimport { InternalDispatchedActionResults } from '../internal/dispatcher';\nimport { StateContextFactory } from '../internal/state-context-factory';\n\n/**\n * State factory class\n * @ignore\n */\n@Injectable()\nexport class StateFactory {\n  get states(): MappedStore[] {\n    return this._parentFactory ? this._parentFactory.states : this._states;\n  }\n\n  private _states: MappedStore[] = [];\n  private _connected = false;\n\n  constructor(\n    private _injector: Injector,\n    @Optional()\n    @SkipSelf()\n    private _parentFactory: StateFactory,\n    private _actions: InternalActions,\n    private _actionResults: InternalDispatchedActionResults,\n    private _stateContextFactory: StateContextFactory\n  ) {}\n\n  /**\n   * Add a new state to the global defs.\n   */\n  add(oneOrManyStateClasses: StateClass | StateClass[]): MappedStore[] {\n    let stateClasses: StateClass[];\n    if (!Array.isArray(oneOrManyStateClasses)) {\n      stateClasses = [oneOrManyStateClasses];\n    } else {\n      stateClasses = oneOrManyStateClasses;\n    }\n\n    const stateGraph = buildGraph(stateClasses);\n    const sortedStates = topologicalSort(stateGraph);\n    const depths = findFullParentPath(stateGraph);\n    const nameGraph = nameToState(stateClasses);\n    const mappedStores: MappedStore[] = [];\n\n    for (const name of sortedStates) {\n      const stateClass = nameGraph[name];\n\n      if (!stateClass[META_KEY]) {\n        throw new Error('States must be decorated with @State() decorator');\n      }\n\n      const depth = depths[name];\n      const { actions } = stateClass[META_KEY];\n      let { defaults } = stateClass[META_KEY];\n\n      stateClass[META_KEY].path = depth;\n\n      // ensure our store hasn't already been added\n      // but dont throw since it could be lazy\n      // loaded from different paths\n      const has = this.states.find(s => s.name === name);\n      if (!has) {\n        // create new instance of defaults\n        if (Array.isArray(defaults)) {\n          defaults = [...defaults];\n        } else if (isObject(defaults)) {\n          defaults = { ...defaults };\n        } else if (defaults === undefined) {\n          defaults = {};\n        }\n\n        const instance = this._injector.get(stateClass);\n\n        mappedStores.push({\n          actions,\n          instance,\n          defaults,\n          name,\n          depth\n        });\n      }\n    }\n\n    this.states.push(...mappedStores);\n\n    return mappedStores;\n  }\n\n  /**\n   * Add a set of states to the store and return the defaulsts\n   */\n  addAndReturnDefaults(stateClasses: any[]): { defaults: any; states: MappedStore[] } {\n    if (stateClasses) {\n      const states = this.add(stateClasses);\n      const defaults = states.reduce(\n        (result: any, meta: MappedStore) => setValue(result, meta.depth, meta.defaults),\n        {}\n      );\n      return { defaults, states };\n    }\n  }\n\n  /**\n   * Bind the actions to the handlers\n   */\n  connectActionHandlers() {\n    if (this._connected) return;\n    this._actions\n      .pipe(\n        filter((ctx: ActionContext) => ctx.status === ActionStatus.Dispatched),\n        mergeMap(({ action }) =>\n          this.invokeActions(this._actions, action).pipe(\n            map(() => <ActionContext>{ action, status: ActionStatus.Successful }),\n            defaultIfEmpty(<ActionContext>{ action, status: ActionStatus.Canceled }),\n            catchError(error => of(<ActionContext>{ action, status: ActionStatus.Errored, error }))\n          )\n        )\n      )\n      .subscribe(ctx => this._actionResults.next(ctx));\n    this._connected = true;\n  }\n\n  /**\n   * Invoke the init function on the states.\n   */\n  invokeInit(stateMetadatas: MappedStore[]) {\n    for (const metadata of stateMetadatas) {\n      const instance: NgxsLifeCycle = metadata.instance;\n\n      if (instance.ngxsOnInit) {\n        const stateContext = this.createStateContext(metadata);\n        instance.ngxsOnInit(stateContext);\n      }\n    }\n  }\n\n  /**\n   * Invoke actions on the states.\n   */\n  invokeActions(actions$: InternalActions, action) {\n    const results = [];\n\n    for (const metadata of this.states) {\n      const type = getActionTypeFromInstance(action);\n      const actionMetas = metadata.actions[type];\n\n      if (actionMetas) {\n        for (const actionMeta of actionMetas) {\n          const stateContext = this.createStateContext(metadata);\n          try {\n            let result = metadata.instance[actionMeta.fn](stateContext, action);\n\n            if (result instanceof Promise) {\n              result = from(result);\n            }\n\n            if (result instanceof Observable) {\n              result = result.pipe(\n                actionMeta.options.cancelUncompleted\n                  ? takeUntil(actions$.pipe(ofActionDispatched(action)))\n                  : map(r => r)\n              ); // map acts like a noop\n            } else {\n              result = of({}).pipe(shareReplay());\n            }\n\n            results.push(result);\n          } catch (e) {\n            results.push(throwError(e));\n          }\n        }\n      }\n    }\n\n    if (!results.length) {\n      results.push(of({}));\n    }\n\n    return forkJoin(results);\n  }\n\n  /**\n   * Create the state context\n   */\n  private createStateContext(metadata: MappedStore) {\n    return this._stateContextFactory.createStateContext(metadata);\n  }\n}\n",
    "function defaultEqualityCheck(a, b) {\n  return a === b;\n}\n\nfunction areArgumentsShallowlyEqual(equalityCheck, prev, next) {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false;\n  }\n\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n  const length = prev.length;\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Memoize a function on its last inputs only.\n * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\n *\n * @ignore\n */\nexport function memoize(func, equalityCheck = defaultEqualityCheck) {\n  let lastArgs = null;\n  let lastResult = null;\n  // we reference arguments instead of spreading them for performance reasons\n  return <(...args) => any>function memoized() {\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult = func.apply(null, arguments);\n    }\n\n    lastArgs = arguments;\n    return lastResult;\n  };\n}\n",
    "import {\n  SelectFromState,\n  fastPropGetter,\n  ensureSelectorMetadata,\n  getSelectorMetadata,\n  getStoreMetadata\n} from '../internal/internals';\nimport { memoize } from '../utils/memoize';\n\n/**\n * Function for creating a selector\n * @param selectors The selectors to use to create the arguments of this function\n * @param originalFn The original function being made into a selector\n */\nexport function createSelector(\n  selectors: any[],\n  originalFn: any,\n  creationMetadata?: { containerClass: any; selectorName: string }\n) {\n  const wrappedFn = function wrappedSelectorFn(...args) {\n    const returnValue = originalFn(...args);\n    if (returnValue instanceof Function) {\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n    return returnValue;\n  };\n  const memoizedFn = memoize(wrappedFn);\n  const containerClass = creationMetadata && creationMetadata.containerClass;\n\n  const fn = state => {\n    const results = [];\n\n    const selectorsToApply = [];\n\n    if (containerClass) {\n      // If we are on a state class, add it as the first selector parameter\n      const metadata = getStoreMetadata(containerClass);\n      if (metadata) {\n        selectorsToApply.push(containerClass);\n      }\n    }\n    if (selectors) {\n      selectorsToApply.push(...selectors);\n    }\n    // Determine arguments from the app state using the selectors\n    if (selectorsToApply) {\n      results.push(...selectorsToApply.map(a => getSelectorFn(a)(state)));\n    }\n\n    // if the lambda tries to access a something on the\n    // state that doesn't exist, it will throw a TypeError.\n    // since this is quite usual behaviour, we simply return undefined if so.\n    try {\n      return memoizedFn(...results);\n    } catch (ex) {\n      if (ex instanceof TypeError) {\n        return undefined;\n      }\n      throw ex;\n    }\n  };\n\n  const selectorMetaData = ensureSelectorMetadata(memoizedFn);\n  selectorMetaData.originalFn = originalFn;\n  selectorMetaData.selectFromAppState = fn;\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName;\n  }\n  return memoizedFn;\n}\n\n/**\n * This function gets the selector function to be used to get the selected slice from the app state\n * @ignore\n */\nexport function getSelectorFn(selector: any): SelectFromState {\n  const selectorMetadata = getSelectorMetadata(selector);\n  if (selectorMetadata) {\n    const selectFromAppState = selectorMetadata.selectFromAppState;\n    if (selectFromAppState) {\n      return selectFromAppState;\n    }\n  }\n  const stateMetadata = getStoreMetadata(selector);\n  if (stateMetadata && stateMetadata.path) {\n    return fastPropGetter(stateMetadata.path.split('.'));\n  }\n  return selector;\n}\n",
    "import { Injectable, NgZone } from '@angular/core';\nimport { Observable, of, Subscription } from 'rxjs';\nimport { catchError, distinctUntilChanged, map, take } from 'rxjs/operators';\n\nimport { getSelectorFn } from './utils/selector-utils';\nimport { InternalStateOperations } from './internal/state-operations';\nimport { StateStream } from './internal/state-stream';\nimport { enterZone } from './operators/zone';\n\n@Injectable()\nexport class Store {\n  constructor(\n    private _ngZone: NgZone,\n    private _stateStream: StateStream,\n    private _internalStateOperations: InternalStateOperations\n  ) {}\n\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(event: any | any[]): Observable<any> {\n    return this._internalStateOperations.getRootStateOperations().dispatch(event);\n  }\n\n  /**\n   * Selects a slice of data from the store.\n   */\n  select<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\n  select(selector: string | any): Observable<any>;\n  select(selector: any): Observable<any> {\n    const selectorFn = getSelectorFn(selector);\n    return this._stateStream.pipe(\n      map(selectorFn),\n      catchError(err => {\n        // if error is TypeError we swallow it to prevent usual errors with property access\n        if (err instanceof TypeError) {\n          return of(undefined);\n        }\n\n        // rethrow other errors\n        throw err;\n      }),\n      distinctUntilChanged(),\n      enterZone(this._ngZone)\n    );\n  }\n\n  /**\n   * Select one slice of data from the store.\n   */\n  selectOnce<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\n  selectOnce(selector: string | any): Observable<any>;\n  selectOnce(selector: any): Observable<any> {\n    return this.select(selector).pipe(take(1));\n  }\n\n  /**\n   * Select a snapshot from the state.\n   */\n  selectSnapshot<T>(selector: (state: any, ...states: any[]) => T): T;\n  selectSnapshot(selector: string | any): any;\n  selectSnapshot(selector: any): any {\n    const selectorFn = getSelectorFn(selector);\n    return selectorFn(this._stateStream.getValue());\n  }\n\n  /**\n   * Allow the user to subscribe to the root of the state\n   */\n  subscribe(fn?: any): Subscription {\n    return this._stateStream.pipe(enterZone(this._ngZone)).subscribe(fn);\n  }\n\n  /**\n   * Return the raw value of the state.\n   */\n  snapshot(): any {\n    return this._internalStateOperations.getRootStateOperations().getState();\n  }\n\n  /**\n   * Reset the state to a specific point in time. This method is useful\n   * for plugin's who need to modify the state directly or unit testing.\n   */\n  reset(state: any) {\n    return this._internalStateOperations.getRootStateOperations().setState(state);\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport { Store } from '../store';\nimport { fastPropGetter } from '../internal/internals';\nimport { META_KEY } from '../symbols';\n\n/**\n * Allows the select decorator to get access to the DI store.\n * @ignore\n */\n@Injectable()\nexport class SelectFactory {\n  static store: Store | undefined = undefined;\n  constructor(store: Store) {\n    SelectFactory.store = store;\n  }\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n */\nexport function Select(selectorOrFeature?, ...paths: string[]) {\n  return function(target: any, name: string) {\n    const selectorFnName = '__' + name + '__selector';\n\n    if (!selectorOrFeature) {\n      // if foo$ => make it just foo\n      selectorOrFeature = name.lastIndexOf('$') === name.length - 1 ? name.substring(0, name.length - 1) : name;\n    }\n\n    const createSelect = fn => {\n      const store = SelectFactory.store;\n\n      if (!store) {\n        throw new Error('SelectFactory not connected to store!');\n      }\n\n      return store.select(fn);\n    };\n\n    const createSelector = () => {\n      if (typeof selectorOrFeature === 'string') {\n        const propsArray = paths.length ? [selectorOrFeature, ...paths] : selectorOrFeature.split('.');\n\n        return fastPropGetter(propsArray);\n      } else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {\n        return fastPropGetter(selectorOrFeature[META_KEY].path.split('.'));\n      } else {\n        return selectorOrFeature;\n      }\n    };\n\n    if (target[selectorFnName]) {\n      throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');\n    }\n\n    if (delete target[name]) {\n      Object.defineProperty(target, selectorFnName, {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      });\n\n      Object.defineProperty(target, name, {\n        get: function() {\n          return this[selectorFnName] || (this[selectorFnName] = createSelect.apply(this, [createSelector()]));\n        },\n        enumerable: true,\n        configurable: true\n      });\n    }\n  };\n}\n",
    "/**\n * Init action\n */\nexport class InitState {\n  static readonly type = '@@INIT';\n}\n\n/**\n * Update action\n */\nexport class UpdateState {\n  static readonly type = '@@UPDATE_STATE';\n}\n",
    "import { NgModule, ModuleWithProviders, Optional, Inject, InjectionToken } from '@angular/core';\n\nimport { ROOT_STATE_TOKEN, FEATURE_STATE_TOKEN, NgxsConfig } from './symbols';\nimport { StateFactory } from './internal/state-factory';\nimport { StateContextFactory } from './internal/state-context-factory';\nimport { Actions, InternalActions } from './actions-stream';\nimport { InternalDispatcher, InternalDispatchedActionResults } from './internal/dispatcher';\nimport { InternalStateOperations } from './internal/state-operations';\nimport { Store } from './store';\nimport { SelectFactory } from './decorators/select';\nimport { StateStream } from './internal/state-stream';\nimport { PluginManager } from './plugin-manager';\nimport { InitState, UpdateState } from './actions/actions';\n\n/**\n * Root module\n * @ignore\n */\n@NgModule()\nexport class NgxsRootModule {\n  constructor(\n    factory: StateFactory,\n    internalStateOperations: InternalStateOperations,\n    store: Store,\n    select: SelectFactory,\n    @Optional()\n    @Inject(ROOT_STATE_TOKEN)\n    states: any[]\n  ) {\n    // add stores to the state graph and return their defaults\n    const results = factory.addAndReturnDefaults(states);\n\n    const stateOperations = internalStateOperations.getRootStateOperations();\n    if (results) {\n      // get our current stream\n      const cur = stateOperations.getState();\n\n      // set the state to the current + new\n      stateOperations.setState({ ...cur, ...results.defaults });\n    }\n\n    // connect our actions stream\n    factory.connectActionHandlers();\n\n    // dispatch the init action and invoke init function after\n    stateOperations.dispatch(new InitState()).subscribe(() => {\n      if (results) {\n        factory.invokeInit(results.states);\n      }\n    });\n  }\n}\n\n/**\n * Feature module\n * @ignore\n */\n@NgModule({})\nexport class NgxsFeatureModule {\n  constructor(\n    store: Store,\n    internalStateOperations: InternalStateOperations,\n    factory: StateFactory,\n    @Optional()\n    @Inject(FEATURE_STATE_TOKEN)\n    states: any[][]\n  ) {\n    // Since FEATURE_STATE_TOKEN is a multi token, we need to\n    // flatten it [[Feature1State, Feature2State], [Feature3State]]\n    const flattenedStates = ([] as any[]).concat(...states);\n\n    // add stores to the state graph and return their defaults\n    const results = factory.addAndReturnDefaults(flattenedStates);\n\n    const stateOperations = internalStateOperations.getRootStateOperations();\n    if (results) {\n      // get our current stream\n      const cur = stateOperations.getState();\n\n      // set the state to the current + new\n      stateOperations.setState({ ...cur, ...results.defaults });\n    }\n\n    stateOperations.dispatch(new UpdateState()).subscribe(() => {\n      if (results) {\n        factory.invokeInit(results.states);\n      }\n    });\n  }\n}\n\nexport type ModuleOptions = Partial<NgxsConfig>;\n\nexport function ngxsConfigFactory(options: ModuleOptions): NgxsConfig {\n  const config = Object.assign(new NgxsConfig(), options);\n  return config;\n}\n\nexport const ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\n\n/**\n * Ngxs Module\n */\n@NgModule({})\nexport class NgxsModule {\n  /**\n   * Root module factory\n   */\n  static forRoot(states: any[] = [], options: ModuleOptions = {}): ModuleWithProviders {\n    return {\n      ngModule: NgxsRootModule,\n      providers: [\n        StateFactory,\n        StateContextFactory,\n        Actions,\n        InternalActions,\n        InternalDispatcher,\n        InternalDispatchedActionResults,\n        InternalStateOperations,\n        Store,\n        StateStream,\n        SelectFactory,\n        PluginManager,\n        ...states,\n        {\n          provide: ROOT_STATE_TOKEN,\n          useValue: states\n        },\n        {\n          provide: ROOT_OPTIONS,\n          useValue: options\n        },\n        {\n          provide: NgxsConfig,\n          useFactory: ngxsConfigFactory,\n          deps: [ROOT_OPTIONS]\n        }\n      ]\n    };\n  }\n\n  /**\n   * Feature module factory\n   */\n  static forFeature(states: any[]): ModuleWithProviders {\n    return {\n      ngModule: NgxsFeatureModule,\n      providers: [\n        StateFactory,\n        PluginManager,\n        ...states,\n        {\n          provide: FEATURE_STATE_TOKEN,\n          multi: true,\n          useValue: states\n        }\n      ]\n    };\n  }\n}\n",
    "import { ensureStoreMetadata } from '../internal/internals';\nimport { StoreOptions, META_KEY } from '../symbols';\n\nconst stateNameRegex = new RegExp('^[a-zA-Z0-9]+$');\n\n/**\n * Error message\n * @ignore\n */\nexport const stateNameErrorMessage = name =>\n  `${name} is not a valid state name. It needs to be a valid object property name.`;\n\n/**\n * Decorates a class with ngxs state information.\n */\nexport function State<T>(options: StoreOptions<T>) {\n  return function(target: any) {\n    const meta = ensureStoreMetadata(target);\n\n    // Handle inheritance\n    if (Object.getPrototypeOf(target).hasOwnProperty(META_KEY)) {\n      const parentMeta = Object.getPrototypeOf(target)[META_KEY];\n\n      meta.actions = {\n        ...meta.actions,\n        ...parentMeta.actions\n      };\n    }\n\n    meta.children = options.children;\n    meta.defaults = options.defaults;\n    meta.name = options.name;\n\n    if (!options.name) {\n      throw new Error(`States must register a 'name' property`);\n    }\n\n    if (!stateNameRegex.test(options.name)) {\n      throw new Error(stateNameErrorMessage(options.name));\n    }\n  };\n}\n",
    "import { ensureStoreMetadata } from '../internal/internals';\nimport { ActionOptions } from '../symbols';\n\n/**\n * Decorates a method with a action information.\n */\nexport function Action(actions: any | any[], options?: ActionOptions) {\n  return function(target: any, name: string, descriptor: TypedPropertyDescriptor<any>) {\n    const meta = ensureStoreMetadata(target.constructor);\n\n    if (!Array.isArray(actions)) {\n      actions = [actions];\n    }\n\n    for (const action of actions) {\n      const type = action.type;\n\n      if (!action.type) {\n        throw new Error(`Action ${action.name} is missing a static \"type\" property`);\n      }\n\n      if (!meta.actions[type]) {\n        meta.actions[type] = [];\n      }\n\n      meta.actions[type].push({\n        fn: name,\n        options: options || {},\n        type\n      });\n    }\n  };\n}\n",
    "import { createSelector } from '../utils/selector-utils';\n\n/**\n * Decorator for memoizing a state selector.\n */\nexport function Selector(selectors?: any[]) {\n  return (target: any, key: string, descriptor: PropertyDescriptor) => {\n    if (descriptor.value !== null) {\n      const originalFn = descriptor.value;\n\n      const memoizedFn = createSelector(selectors, originalFn, { containerClass: target, selectorName: key });\n\n      return {\n        configurable: true,\n        get() {\n          return memoizedFn;\n        }\n      };\n    } else {\n      throw new Error('Selectors only work on methods');\n    }\n  };\n}\n"
  ],
  "names": [
    "ROOT_STATE_TOKEN",
    "InjectionToken",
    "FEATURE_STATE_TOKEN",
    "META_KEY",
    "SELECTOR_META_KEY",
    "NGXS_PLUGINS",
    "NgxsConfig",
    "ensureStoreMetadata",
    "target",
    "hasOwnProperty",
    "Object",
    "defineProperty",
    "value",
    "name",
    "actions",
    "defaults",
    "path",
    "children",
    "instance",
    "getStoreMetadata",
    "getSelectorMetadata",
    "fastPropGetter",
    "paths",
    "segments",
    "seg",
    "i",
    "l",
    "length",
    "expr",
    "Function",
    "getActionTypeFromInstance",
    "action",
    "constructor",
    "type",
    "setValue",
    "obj",
    "prop",
    "val",
    "assign",
    "split",
    "lastIndex",
    "reduce",
    "acc",
    "part",
    "index",
    "getValue",
    "ofActionOperator",
    "allowedTypes",
    "status",
    "allowedMap",
    "enterZone",
    "zone",
    "source",
    "Observable",
    "sink",
    "subscribe",
    "next",
    "x",
    "run",
    "error",
    "e",
    "complete",
    "OrderedSubject",
    "_this",
    "_super",
    "apply",
    "this",
    "tslib_1.__spread",
    "arguments",
    "_busyPushingNext",
    "prototype",
    "_itemQueue",
    "unshift",
    "call",
    "nextValue",
    "pop",
    "Subject",
    "InternalActions",
    "decorators",
    "Injectable",
    "observer",
    "actions$",
    "compose",
    "funcs",
    "args",
    "_i",
    "StateStream",
    "tslib_1.__extends",
    "PluginManager",
    "_parentManager",
    "_plugins",
    "plugins",
    "register",
    "map",
    "plugin",
    "handle",
    "bind",
    "_a",
    "push",
    "InternalDispatchedActionResults",
    "InternalDispatcher",
    "_errorHandler",
    "_actions",
    "_actionResults",
    "_pluginManager",
    "_stateStream",
    "_ngZone",
    "dispatch",
    "event",
    "result",
    "runOutsideAngular",
    "Array",
    "isArray",
    "forkJoin",
    "a",
    "dispatchSingle",
    "handleError",
    "pipe",
    "prevState",
    "nextState",
    "nextAction",
    "actionResult$",
    "getActionResultStream",
    "ctx",
    "createDispatchObservable",
    "shareReplay",
    "filter",
    "take",
    "exhaustMap",
    "throwError",
    "deepFreeze",
    "o",
    "freeze",
    "oIsFunction",
    "hasOwnProp",
    "getOwnPropertyNames",
    "forEach",
    "isFrozen",
    "InternalStateOperations",
    "_dispatcher",
    "_config",
    "getRootStateOperations",
    "rootStateOperations",
    "getState",
    "setState",
    "newState",
    "developmentMode",
    "ensureStateAndActionsAreImmutable",
    "root",
    "frozenValue",
    "ctorParameters",
    "StateContextFactory",
    "_internalStateOperations",
    "createStateContext",
    "metadata",
    "state",
    "depth",
    "patchState",
    "isPrimitive",
    "Error",
    "local",
    "clone",
    "k",
    "StateFactory",
    "_injector",
    "_parentFactory",
    "_stateContextFactory",
    "_states",
    "_connected",
    "get",
    "configurable",
    "add",
    "oneOrManyStateClasses",
    "stateClasses",
    "findName",
    "graph",
    "sorted",
    "visited",
    "visit",
    "e_1",
    "_b",
    "stateGraph",
    "stateClass",
    "meta",
    "find",
    "g",
    "sortedStates",
    "ancestors",
    "dep",
    "indexOf",
    "join",
    "slice",
    "keys",
    "depths",
    "newObj",
    "child",
    "keyToFind",
    "key",
    "parent_1",
    "parent_2",
    "findFullParentPath",
    "nameGraph",
    "mappedStores",
    "_loop_1",
    "name_1",
    "this_1",
    "states",
    "s",
    "undefined",
    "sortedStates_1",
    "tslib_1.__values",
    "sortedStates_1_1",
    "done",
    "e_1_1",
    "mergeMap",
    "invokeActions",
    "defaultIfEmpty",
    "catchError",
    "of",
    "invokeInit",
    "stateMetadatas",
    "stateMetadatas_1",
    "stateMetadatas_1_1",
    "ngxsOnInit",
    "stateContext",
    "e_2_1",
    "e_2",
    "return",
    "actionMetas",
    "actionMeta",
    "fn",
    "Promise",
    "from",
    "defaultEqualityCheck",
    "b",
    "memoize",
    "func",
    "equalityCheck",
    "lastArgs",
    "prev",
    "lastResult",
    "createSelector",
    "selectors",
    "originalFn",
    "creationMetadata",
    "memoizedFn",
    "returnValue",
    "selectorMetaData",
    "selectFromAppState",
    "containerClass",
    "selectorName",
    "ensureSelectorMetadata",
    "results",
    "selectorsToApply",
    "getSelectorFn",
    "ex",
    "TypeError",
    "selector",
    "selectorMetadata",
    "stateMetadata",
    "Store",
    "select",
    "selectorFn",
    "err",
    "distinctUntilChanged",
    "selectOnce",
    "selectSnapshot",
    "snapshot",
    "reset",
    "NgZone",
    "SelectFactory",
    "store",
    "InitState",
    "NgxsRootModule",
    "factory",
    "addAndReturnDefaults",
    "stateOperations",
    "internalStateOperations",
    "cur",
    "flattenedStates",
    "concat",
    "UpdateState",
    "NgModule",
    "Optional",
    "Inject",
    "NgxsModule",
    "forRoot",
    "options",
    "ngModule",
    "providers",
    "Actions",
    "provide",
    "useValue",
    "ROOT_OPTIONS",
    "useFactory",
    "ngxsConfigFactory",
    "deps",
    "forFeature",
    "NgxsFeatureModule",
    "stateNameRegex",
    "RegExp",
    "stateNameErrorMessage",
    "descriptor",
    "actions_1",
    "actions_1_1",
    "getPrototypeOf",
    "parentMeta",
    "test",
    "selectorOrFeature",
    "selectorFnName",
    "lastIndexOf",
    "substring",
    "writable",
    "enumerable",
    "memoizedFn_1",
    "action1",
    "type1",
    "action2"
  ],
  "mappings": "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"
}
